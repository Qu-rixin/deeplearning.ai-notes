# Keras tutorial - the Happy House

​		在本次任务中，你将：

+ 学习使用keras，一个高级的神经网络api（编程框架），用python编写，能够运行在几个低级框架之上，包括tensorflow和cntk。

+ 看看你如何在几个小时内建立一个深度学习算法。

​		为什么我们要用keras？开发Keras的目的是使深入学习的工程师能够非常快速地构建和实验不同的模型。正如tensorflow是一个比python更高级别的框架一样，keras是一个更高级别的框架，并提供了额外的抽象。能够以最小的延迟从想法到结果的关键是找到一个好的模型。然而，keras比低级框架更具限制性，因此有一些非常复杂的模型可以在tensorflow中实现，但在keras中不能（没有更多困难）实现。也就是说，对于许多常见的模型来说，Keras都能很好地工作。

## 1. The Happy House

​		下一个假期，你决定和五个来自学校的朋友一起度过一个星期。这是一个非常方便的房子，附近有很多事情要做。但最重要的好处是，每个人在家里都承诺要快乐。因此，任何想进入这所房子的人都必须证明他们目前的幸福状态。

![](C:\Users\Think\Desktop\吴恩达笔记\04-Convolution Neural Networks\week2\KerasTutorial\imgs\happy-house.jpg)

​		作为一个深度学习的专家，为了确保“快乐”规则得到严格的应用，您将构建一个算法，该算法使用来自前门摄像头的图片来检查此人是否快乐。只有当这个人高兴的时候，门才应该打开。

​		你已经收集了你的朋友和你自己的照片，由前门摄像头拍摄。数据集已标记。

![](C:\Users\Think\Desktop\吴恩达笔记\04-Convolution Neural Networks\week2\KerasTutorial\imgs\house-members.png)

## 2. Building a model in Keras

​		Keras非常适合快速成型。在很短的时间内，你将能够建立一个模型，取得杰出的成果。

​		下面是Keras中的一个模型示例：

```python
def model(input_shape):
    # Define the input placeholder as a tensor with shape input_shape. Think of this as your input image!
    X_input = Input(input_shape)

    # Zero-Padding: pads the border of X_input with zeroes
    X = ZeroPadding2D((3, 3))(X_input)

    # CONV -> BN -> RELU Block applied to X
    X = Conv2D(32, (7, 7), strides = (1, 1), name = 'conv0')(X)
    X = BatchNormalization(axis = 3, name = 'bn0')(X)
    X = Activation('relu')(X)

    # MAXPOOL
    X = MaxPooling2D((2, 2), name='max_pool')(X)

    # FLATTEN X (means convert it to a vector) + FULLYCONNECTED
    X = Flatten()(X)
    X = Dense(1, activation='sigmoid', name='fc')(X)

    # Create model. This creates your Keras model instance, you'll use this instance to train/test the model.
    model = Model(inputs = X_input, outputs = X, name='HappyModel')

    return model
```

​		注意，keras对变量名使用的惯例不同于我们以前对numpy和tensorflow使用的约定。尤其是，不是在正向传播的每一步上创建和分配一个新变量，例如x、z1、a1、z2、a2等，以便为不同层的计算，在keras代码中，上面的每一行只是使用x=….将x重新分配给一个新值。换言之，在正向传播的每个步骤中，我们只是将最新的值写入同一个变量x中。唯一的例外是x_input，我们将其分开，并且没有覆盖，因为我们需要它在最后创建上面的keras模型实例（model=model（inputs=x_input，…）。

​		练习：实现happyModel（）。这项作业比大多数作业更开放。我们建议您首先使用我们建议的架构实现一个模型，然后使用该模型作为您的初始模型运行本任务的其余部分。但在那之后，回来并主动尝试其他模型架构。例如，您可以从上面的模型中获得灵感，但随后可以根据需要更改网络架构和超参数。您还可以使用其他函数，如averagePooling2D（）、globalMaxPooling2D（）、dropout（）。

```python
def HappyModel(input_shape):
    """
    Implementation of the HappyModel.
    
    Arguments:
    input_shape -- shape of the images of the dataset

    Returns:
    model -- a Model() instance in Keras
    """
    
    # Feel free to use the suggested outline in the text above to get started, and run through the whole
    # exercise (including the later portions of this notebook) once. The come back also try out other
    # network architectures as well. 
    # Define the input placeholder as a tensor with shape input_shape. Think of this as your input image!
    X_input = Input(input_shape)

    # Zero-Padding: pads the border of X_input with zeroes
    X = ZeroPadding2D((3, 3))(X_input)

    # CONV -> BN -> RELU Block applied to X
    X = Conv2D(32, (7, 7), strides = (1, 1), name = 'conv0')(X)
    X = BatchNormalization(axis = 3, name = 'bn0')(X)
    X = Activation('relu')(X)

    # MAXPOOL
    X = MaxPooling2D((2, 2), name='max_pool')(X)

    # FLATTEN X (means convert it to a vector) + FULLYCONNECTED
    X = Flatten()(X)
    X = Dense(1, activation='sigmoid', name='fc')(X)

    # Create model. This creates your Keras model instance, you'll use this instance to train/test the model.
    model = Model(inputs = X_input, outputs = X, name='HappyModel')
    
    
    return model
```

​		现在您已经构建了一个函数来描述您的模型。要训练和测试此模型，在keras中有四个步骤：

		1. 通过调用上面的函数创建模型。
  		2. 通过调用model.compile（optimizer=“…”，loss=“…”，metrics=[“accurity”]）来编译模型。
  		3. 通过调用model.fit（x=…，y=…，epochs=…，batch_size=…）模型上训练数据。
  		4. 通过调用model.evaluate（x=…，y=…）在测试数据上测试模型。

创建模型；

```python
happyModel = HappyModel((64,64,3))
```

配置学习过程来编译模型：

```python
happyModel.compile(optimizer='adam', loss="binary_crossentropy", metrics=['accuracy'])
```

这个问题是一个二分类问题。

训练模型，选择迭代次数和batch大小：

```python
happyModel.fit(x=X_train, y=Y_train, epochs=10, batch_size=20)
```

请注意，如果再次运行fit（），模型将继续使用它已经学习的参数进行训练，而不是重新初始化它们。

测试和评估模型：

```python
preds = happyModel.evaluate(x=X_test, y=Y_test,)
print()
print ("Loss = " + str(preds[0]))
print ("Test Accuracy = " + str(preds[1]))
```

​		如果happyModel（）函数起作用，那么您应该在训练集和测试集上观察到比随机猜测（50%）更高的准确性。

​		为了给你一个比较点，我们的模型在40次迭代（和99%的训练精度）得到了大约95%的测试精度，mini-batch大小为16和“Adam”优化器。但是我们的模型在2-5个阶段之后就获得了相当高的精度，所以如果你比较不同的模型，你也可以在几个阶段上训练各种模型，看看它们是如何比较的。

​		如果你还没有达到很好的准确度（比如说超过80%），以下是一些你可以尝试的东西：

		+ 尝试使用CONV->BATCHNORM->RELU块，例如：

```python
X = Conv2D(32, (3, 3), strides = (1, 1), name = 'conv0')(X)
X = BatchNormalization(axis = 3, name = 'bn0')(X)
X = Activation('relu')(X)
```

​		直到你的高度和宽度维度相当低，你的通道数量相当大（例如≈32）。你正在一个有很多通道的体中编码有用的信息。然后可以展平体并使用完全连接层。

  + 在这些块之后可以使用maxpool。它将帮助您降低维度的高度和宽度。

  + 改变优化器。我们发现Adam效果更好。

  + 如果模型运行困难，并且出现内存问题，请降低mini-batch大小（12通常是一个很好的折衷方案）

  + 运行更多次迭代，直到你看到训练的精度趋于稳定。

    即使你已经取得了很好的准确性，请随时继续玩你的模型，以试图获得更好的结果。

​		注意：如果对模型执行超参数优化，那么测试集实际上会变成一个开发集，并且您的模型可能最终与测试（开发）集过拟合。但就这项任务而言，我们不必担心。

## 3. Conclusion

**我们希望您记住本次任务中的内容：**

+ Keras是我们推荐用于快速原型制作的工具。它允许您快速尝试不同的模型架构。有没有什么深入学习的应用到你的日常生活中，你想实现使用Keras？
+ 记住如何在keras中编写模型代码，以及在测试集中评估模型的四个步骤。创建->编译->装配/训练->评估/测试。

## 4. Test with your own image (Optional)

​		训练/测试集非常相似；例如，所有图片都是在同一背景下拍摄的（因为前门摄像头总是安装在同一位置）。这使得问题更容易解决，但是基于此数据训练的模型可能对您自己的数据起作用，也可能不起作用。但你可以试试看！

## 5. Other useful functions in Keras (Optional)

​		你将发现有用的两个keras的基本特征：

+ model.summary()：在表中打印各层的细节
+ plot_model()：画出布局图

