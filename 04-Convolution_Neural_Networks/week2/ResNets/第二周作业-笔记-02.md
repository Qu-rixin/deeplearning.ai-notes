# Residual Networks

​		欢迎来到本周的第二个作业！您将学习如何使用残差网络（ResNets）构建非常深的卷积网络。理论上，非常深的网络可以表示非常复杂的功能；但实际上，它们很难训练。He等人引入的残差网络允许你训练比以前实际可行的更深层次的网络。

**In this assignment, you will:**

+ 实现resnets的基本构建块。

+ 将这些构建块组合在一起，实现并训练用于图像分类的最先进神经网络。

## 1. The problem of very deep neural networks

​		上周，你建立了第一个卷积神经网络。近年来，神经网络变得越来越深入，最先进的网络从几层（如AlexNet）发展到超过一百层。

​		非常深的网络的主要优点是它可以表示非常复杂的函数。它还可以在许多不同的抽象层次上学习特征，从边缘（底层）到非常复杂的特征（深层）。然而，使用更深层的网络并不总是有帮助的。训练它们的一个巨大障碍是逐渐消失的梯度：非常深的网络通常会有一个很快变为零的梯度信号，从而使梯度下降变得非常缓慢。更具体地说，在梯度下降过程中，当您从最后一层返回到第一层时，您将乘以每一步上的权重矩阵，因此梯度可以迅速地以指数方式减小到零（或者，在极少数情况下，以指数方式快速增长并“爆炸”以获得非常大的值）。

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/04-Convolution_Neural_Networks/week2/ResNets/imgs/vanishing_grad_kiank.png)

## 2. Building a Residual Network

​		在resnets中，“short cut”或“skip connection”允许梯度直接反向传播到更前面的层：

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/04-Convolution_Neural_Networks/week2/ResNets/imgs/skip_connection_kiank.png)

​		左边的图片显示了通过网络的“主路径”。右边的图像为主路径添加了short cut。通过将这些resnet块堆叠在一起，可以形成一个非常深的网络。

​		我们在视频中还看到，使用带有short cut的resnet块也使其中一个块学习标识函数变得非常容易。这意味着您可以叠加在额外的resnet块上，而不会损害训练集的性能。（也有一些证据表明，学习标识函数的容易程度——甚至比跳过有助于渐变消失的连接——是resnets显著性能的原因。）

​		resnet中主要使用两种类型的块，这主要取决于输入/输出维度是相同还是不同。你要实现这两个目标。

### 1. The identity block

​		标识块是resnet中使用的标准块，**对应于输入激活（比如a[l]）与输出激活（比如a[l+2]）具有相同维度的情况**。为了充实resnet标识块中发生的不同步骤，这里有一个显示各个步骤的替代图：

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/04-Convolution_Neural_Networks/week2/ResNets/imgs/idblock2_kiank.png)

​		上面的路径是“short cut”，下面的路径是“主路径”。在这个图中，我们还明确了每个层中的conv2d和relu步骤。为了加快训练速度，我们还增加了一个batchnorm步骤。不要担心实现起来会很复杂——您将看到batchnorm只是keras中的一行代码！

​		在本练习中，您将实际实现此标识块的一个稍微强大的版本，其中跳过连接“跳过”3个隐层，而不是2个层。看起来是这样的：

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/04-Convolution_Neural_Networks/week2/ResNets/imgs/idblock3_kiank.png)

​		主路径的第一个组件：

+ 第一个conv2d具有形状（1,1）和步长（1,1）的f1滤波器。它的填充是“有效的”，它的名称应该是conv_name_base+'2a'。使用0作为随机初始化的种子。

+ 第一个batchnorm是归一化通道轴。它的名字应该是bn_name_base+'2a'。

+ 然后应用relu激活功能。它没有名称也没有超参数。

​		主路径的第二个组件：

+ 第二个conv2d具有形状为（f，f）和步长为（1，1）的f2滤波器。它的填充是“相同的”，它的名称应该是conv_name_base+'2b'。使用0作为随机初始化的种子。

+ 第二个batchnorm是对通道轴线进行归一化处理。它的名称应该是bn_name_base+'2b'。

+ 然后应用relu激活功能。它没有名称也没有超参数。

​		主路径的第三个组件：

+ 第三个conv2d具有形状为（1,1）和步长为（1,1）的f3过滤器。其填充为“有效”，其名称应为conv_name_base+'2c'。使用0作为随机初始化的种子。

+ 第三BatchNorm正对通道轴进行归一化处理。它的名称应该是bn_name_base+'2c'。请注意，此组件中没有RELU激活功能。

​		最后步骤：

+ short cut和输入被添加在一起。
+ 然后应用relu激活功能。它没有名称也没有超参数。

​		练习：实现resnet标识块。我们已经实现了主路径的第一个组件。请仔细阅读这篇文章，以确保你明白它在做什么。你应该实现其余的。

```python
def identity_block(X, f, filters, stage, block):
    """
    Implementation of the identity block as defined in Figure 3
    
    Arguments:
    X -- input tensor of shape (m, n_H_prev, n_W_prev, n_C_prev)
    f -- integer, specifying the shape of the middle CONV's window for the main path
    filters -- python list of integers, defining the number of filters in the CONV layers of the main path
    stage -- integer, used to name the layers, depending on their position in the network
    block -- string/character, used to name the layers, depending on their position in the network
    
    Returns:
    X -- output of the identity block, tensor of shape (n_H, n_W, n_C)
    """
    
    # defining name basis
    conv_name_base = 'res' + str(stage) + block + '_branch'
    bn_name_base = 'bn' + str(stage) + block + '_branch'
    
    # Retrieve Filters
    F1, F2, F3 = filters
    
    # Save the input value. You'll need this later to add back to the main path. 
    X_shortcut = X
    
    # First component of main path
    X = Conv2D(filters = F1, kernel_size = (1, 1), strides = (1,1), padding = 'valid', name = conv_name_base + '2a', kernel_initializer = glorot_uniform(seed=0))(X)
    X = BatchNormalization(axis = 3, name = bn_name_base + '2a')(X)
    X = Activation('relu')(X)
    
    
    # Second component of main path (≈3 lines)
    X = Conv2D(filters = F2, kernel_size = (f,f), strides = (1,1), padding = 'same', name = conv_name_base + '2b', kernel_initializer = glorot_uniform(seed=0))(X)
    X = BatchNormalization(axis=3, name=bn_name_base+'2b')(X)
    X = Activation('relu')(X)
    
    # Third component of main path (≈2 lines)
    X = Conv2D(filters = F3, kernel_size = (1,1), strides = (1,1), padding = 'valid', name = conv_name_base+'2c', kernel_initializer = glorot_uniform(seed=0))(X)
    X = BatchNormalization(axis=3, name=bn_name_base+'2c')(X)

    # Final step: Add shortcut value to main path, and pass it through a RELU activation (≈2 lines)
    X = Add()([X, X_shortcut])
    X = Activation('relu')(X)
    
    
    return X


tf.reset_default_graph()

with tf.Session() as test:
    np.random.seed(1)
    A_prev = tf.placeholder("float", [3, 4, 4, 6])
    X = np.random.randn(3, 4, 4, 6)
    A = identity_block(A_prev, f = 2, filters = [2, 4, 6], stage = 1, block = 'a')
    test.run(tf.global_variables_initializer())
    out = test.run([A], feed_dict={A_prev: X, K.learning_phase(): 0})
    print("out = " + str(out[0][1][1][0]))
```

## 3. The convolutional block

​		您已经实现了resnet标识块。接下来，resnet“卷积块”是另一种类型的块。当**输入和输出维度不匹配时**，可以使用这种类型的块。与标识块的区别在于，short cut路径中有一个conv2d层：

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/04-Convolution_Neural_Networks/week2/ResNets/imgs/convblock_kiank.png)

​		short cut路径中的conv2d层用于将输入x调整为不同的维度，以便在最后的加法中匹配尺寸，以便将short cut值添加回主路径。（这与视频中讨论的矩阵Ws的作用类似）例如，要将激活维度的高度和宽度减少2倍，可以使用步长为2的1x1卷积。short cut上的conv2d层不使用任何非线性激活函数。它的主要作用是应用一个（学习的）线性函数来减少输入的维数，以便维数与后面的加法步骤相匹配。

​		卷积块的细节如下。

主路径的第一个组件：

+ 第一个conv2d具有形状（1,1）和步长（s，s）的f1过滤器。它的填充是“有效的”，它的名称应该是conv_name_base+'2a'。

+ 第一个batchnorm是归一化通道轴。它的名字应该是bn_name_base+'2a'。

+ 然后应用relu激活功能。它没有名称也没有超参数。

​		主路径的第二个组件：

+ 第二个conv2d具有形状为（f，f）和步长为（1,1）的f2滤波器。它的填充是“相同的”，它的名称应该是conv_name_base+'2b'。

+ 第二个batchnorm是对通道轴线进行归一化处理。它的名称应该是bn_name_base+'2b'。

+ 然后应用relu激活功能。它没有名称也没有超参数。

​		主路径的第三个组件：

+ 第三个conv2d具有形状为（1,1）和步长为（1,1）的f3滤波器。它的填充是“有效的”，它的名称应该是conv_name_base+'2c'。

+ 第三BatchNorm正对通道轴进行归一化处理。它的名称应该是bn_name_base+'2c'。请注意，此组件中没有RELU激活功能。

​		short cut路径：

+ conv2d具有形状为（1,1）和步长为（s，s）的过滤器f3。其填充为“有效”，其名称应为conv_name_base+“1”。

+ batchnorm是通道轴的归一化。它的名称应该是bn_name_base+'1'。

​		最后一步：

+ short cut和主路径值相加。

+ 然后应用relu激活功能。它没有名称也没有超参数。

​		练习：实现卷积块。我们已经实现了主路径的第一个组件；您应该实现其余的组件。与以前一样，始终使用0作为随机初始化的种子，以确保与我们的分级器一致。

```python
def convolutional_block(X, f, filters, stage, block, s = 2):
    """
    Implementation of the convolutional block as defined in Figure 4
    
    Arguments:
    X -- input tensor of shape (m, n_H_prev, n_W_prev, n_C_prev)
    f -- integer, specifying the shape of the middle CONV's window for the main path
    filters -- python list of integers, defining the number of filters in the CONV layers of the main path
    stage -- integer, used to name the layers, depending on their position in the network
    block -- string/character, used to name the layers, depending on their position in the network
    s -- Integer, specifying the stride to be used
    
    Returns:
    X -- output of the convolutional block, tensor of shape (n_H, n_W, n_C)
    """
    
    # defining name basis
    conv_name_base = 'res' + str(stage) + block + '_branch'
    bn_name_base = 'bn' + str(stage) + block + '_branch'
    
    # Retrieve Filters
    F1, F2, F3 = filters
    
    # Save the input value
    X_shortcut = X


    ##### MAIN PATH #####
    # First component of main path 
    X = Conv2D(F1, (1, 1), strides = (s,s), name = conv_name_base + '2a', kernel_initializer = glorot_uniform(seed=0))(X)
    X = BatchNormalization(axis = 3, name = bn_name_base + '2a')(X)
    X = Activation('relu')(X)
    

    # Second component of main path (≈3 lines)
    X = Conv2D(F2, (f,f), strides=(1,1), name = conv_name_base + '2b', padding='same' ,kernel_initializer= glorot_uniform(seed=0))(X)
    X = BatchNormalization(axis=3, name = bn_name_base +'2b')(X)
    X = Activation('relu')(X)

    # Third component of main path (≈2 lines)
    X = Conv2D(F3, (1,1), strides=(1,1), name=conv_name_base+'2c', padding='valid', kernel_initializer=glorot_uniform(seed=0))(X)
    X = BatchNormalization(axis=3, name=bn_name_base+'2c')(X)

    ##### SHORTCUT PATH #### (≈2 lines)
    X_shortcut = Conv2D(F3, (1,1), strides=(s,s), name=conv_name_base+'1', padding='valid', kernel_initializer=glorot_uniform(seed=0))(X_shortcut)
    X_shortcut = BatchNormalization(axis=3, name=bn_name_base+'1')(X_shortcut)

    # Final step: Add shortcut value to main path, and pass it through a RELU activation (≈2 lines)
    X = Add()([X, X_shortcut])
    X = Activation('relu')(X)
    
    
    return X


tf.reset_default_graph()

with tf.Session() as test:
    np.random.seed(1)
    A_prev = tf.placeholder("float", [3, 4, 4, 6])
    X = np.random.randn(3, 4, 4, 6)
    A = convolutional_block(A_prev, f = 2, filters = [2, 4, 6], stage = 1, block = 'a')
    test.run(tf.global_variables_initializer())
    out = test.run([A], feed_dict={A_prev: X, K.learning_phase(): 0})
    print("out = " + str(out[0][1][1][0]))
```

## 4. Building your first ResNet model (50 layers)

​		你现在有必要的块来建造一个非常深的resnet。下图详细描述了这种神经网络的架构。图中的“id block”表示“identity block”，“id block x3”表示应该将3个标识块堆叠在一起。

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/04-Convolution_Neural_Networks/week2/ResNets/imgs/resnet_kiank.png)

​		resnet-50模型的详细信息如下：

+ 零填充将输入填充为（3,3）

+ 第一阶段：
  	+ 二维卷积有64个形状为（7,7）步长为（2,2）的滤波器。它的名字叫“conv1”。
  	+ BatchNorm应用于输入的通道轴。
  	+ MaxPooling使用（3,3）窗口和（2,2）步长。
+ 第二阶段：

  	+ 卷积块使用三组大小为[64，64，256]，“f”为3，“s”为1且块为“a”的滤波器。
  	+ 两个标识块使用三组大小为[64，64，256]，“f”为3且块为“b”和“c”的滤波器。
+ 第三阶段：
  	+ 卷积块使用三组大小为[128，128，512]，“f”为3，“s”为2且块为“a”的滤波器。
  	+ 这3个标识块使用3组大小为[128，128，512]，“f”为3且块为“b”、“c”和“d”的滤波器。
+ 第4阶段：
  	+ 卷积块使用三组大小为[256，256，1024]，“f”为3，“s”为2且块为“a”的滤波器。
  	+ 5个标识块使用3组大小为[256，256，1024]的滤波器，“f”为3，块为“b”、“c”、“d”、“e”和“f”。
+ 第5阶段：

  	+ 卷积块使用三组大小为[512，512，2048]，“f”为3，“s”为2且块为“a”的滤波器。
  	+ 两个标识块使用三组大小为[512，512，2048]的滤波器，“f”为3，块为“b”和“c”。
+ 二维平均池化使用形状窗口（2,2），其名称为“avg_pool”。
+ 展平没有任何超参数或名称。
+ 完全连接（密集）层使用softmax激活将其输入减少到类的数量。它的名称应该是'fc'+str（类）

​		练习：使用上图中描述的50层实现resnet。我们已经实施了第一阶段和第二阶段。其余的请执行。（实现阶段3-5的语法应该与阶段2的语法非常相似。）确保遵循上面文本中的命名约定。

```python
def ResNet50(input_shape = (64, 64, 3), classes = 6):
    """
    Implementation of the popular ResNet50 the following architecture:
    CONV2D -> BATCHNORM -> RELU -> MAXPOOL -> CONVBLOCK -> IDBLOCK*2 -> CONVBLOCK -> IDBLOCK*3
    -> CONVBLOCK -> IDBLOCK*5 -> CONVBLOCK -> IDBLOCK*2 -> AVGPOOL -> TOPLAYER

    Arguments:
    input_shape -- shape of the images of the dataset
    classes -- integer, number of classes

    Returns:
    model -- a Model() instance in Keras
    """
    
    # Define the input as a tensor with shape input_shape
    X_input = Input(input_shape)

    
    # Zero-Padding
    X = ZeroPadding2D((3, 3))(X_input)
    
    # Stage 1
    X = Conv2D(64, (7, 7), strides = (2, 2), name = 'conv1', kernel_initializer = glorot_uniform(seed=0))(X)
    X = BatchNormalization(axis = 3, name = 'bn_conv1')(X)
    X = Activation('relu')(X)
    X = MaxPooling2D((3, 3), strides=(2, 2))(X)

    # Stage 2
    X = convolutional_block(X, f = 3, filters = [64, 64, 256], stage = 2, block='a', s = 1)
    X = identity_block(X, 3, [64, 64, 256], stage=2, block='b')
    X = identity_block(X, 3, [64, 64, 256], stage=2, block='c')


    # Stage 3 (≈4 lines)
    X = convolutional_block(X, f = 3, filters = [128, 128, 512], stage = 3, block='a', s = 2)
    X = identity_block(X, 3, [128, 128, 512], stage=3, block='b')
    X = identity_block(X, 3, [128, 128, 512], stage=3, block='c')
    X = identity_block(X, 3, [128, 128, 512], stage=3, block='d')

    # Stage 4 (≈6 lines)
    X = convolutional_block(X, f = 3, filters = [256, 256, 1024], stage = 4, block='a', s = 2)
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='b')
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='c')
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='d')
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='e')
    X = identity_block(X, 3, [256, 256, 1024], stage=4, block='f')

    # Stage 5 (≈3 lines)
    X = convolutional_block(X, f = 3, filters =  [512, 512, 2048], stage = 5, block='a', s = 2)
    X = identity_block(X, 3,  [512, 512, 2048], stage=5, block='b')
    X = identity_block(X, 3,  [512, 512, 2048], stage=5, block='c')

    # AVGPOOL (≈1 line). Use "X = AveragePooling2D(...)(X)"
    X = AveragePooling2D(pool_size=(2, 2), strides=None, padding='valid', data_format=None, name="avg_pool")(X)
    

    # output layer
    X = Flatten()(X)
    X = Dense(classes, activation='softmax', name='fc' + str(classes), kernel_initializer = glorot_uniform(seed=0))(X)
    
    
    # Create model
    model = Model(inputs = X_input, outputs = X, name='ResNet50')

    return model

# load the datasets.
X_train_orig, Y_train_orig, X_test_orig, Y_test_orig, classes = load_dataset()

# Normalize image vectors
X_train = X_train_orig/255.
X_test = X_test_orig/255.

# Convert training and test labels to one hot matrices
Y_train = convert_to_one_hot(Y_train_orig, 6).T
Y_test = convert_to_one_hot(Y_test_orig, 6).T

print ("number of training examples = " + str(X_train.shape[0]))
print ("number of test examples = " + str(X_test.shape[0]))
print ("X_train shape: " + str(X_train.shape))
print ("Y_train shape: " + str(Y_train.shape))
print ("X_test shape: " + str(X_test.shape))
print ("Y_test shape: " + str(Y_test.shape))


# create a model.
model = ResNet50(input_shape = (64, 64, 3), classes = 6)
# compile the model.
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
# train the model.
model.fit(X_train, Y_train, epochs = 2, batch_size = 32)
# evaluate the model.
preds = model.evaluate(X_test, Y_test)
print ("Loss = " + str(preds[0]))
print ("Test Accuracy = " + str(preds[1]))
```

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/04-Convolution_Neural_Networks/week2/ResNets/imgs/signs_data_kiank.png)

​		为了完成这项任务，我们要求你只训练两次迭代的模型。你可以看到它的表现很差。

​		完成此作业的正式（分级）部分后，如果需要，还可以选择对resnet进行更多迭代的培训。当我们训练大约20次迭代时，我们会获得更好的性能，但是在使用CPU训练时，这将需要一个多小时。

​		使用gpu，我们在signs数据集上训练了resnet50模型的权重。您可以在下面的单元中的测试集上加载并运行我们的训练模型。加载模型可能需要大约1分钟。

```python
model = load_model('ResNet50.h5') 
preds = model.evaluate(X_test, Y_test)
print ("Loss = " + str(preds[0]))
print ("Test Accuracy = " + str(preds[1]))
```

​		resnet50是一个强大的图像分类模型，当它被训练为足够的迭代次数。

## 5. Test on your own image (Optional/Ungraded)

```python
img_path = 'images/2.jpg'
img = image.load_img(img_path, target_size=(64, 64))
x = image.img_to_array(img)
x = np.expand_dims(x, axis=0)
x = preprocess_input(x)
print('Input image shape:', x.shape)
my_image = scipy.misc.imread(img_path)
imshow(my_image)
print("class prediction vector [p(0), p(1), p(2), p(3), p(4), p(5)] = ")
print(model.predict(x))
```

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/04-Convolution_Neural_Networks/week2/ResNets/imgs/2.jpg)

**你应该记住的是：**

+ 非常深的“普通”网络在实践中不起作用，因为它们由于梯度消失而难以训练。
+ skip connection有助于解决消失梯度问题。它们还使resnet块很容易学习标识函数。
+ 有两种主要类型的块：标识块和卷积块。
+ 通过将这些块堆叠在一起，形成了非常深的残差网络。

## 6. References

​		本笔记本介绍了He等人提出的resnet算法。（2015年）。这里的实现也得到了很大的启发，并遵循了francois chollet的github仓库中给出的架构：
