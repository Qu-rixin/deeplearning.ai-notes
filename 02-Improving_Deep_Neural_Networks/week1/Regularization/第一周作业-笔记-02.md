# 1. Regularization

​		深度学习模型具有很大的灵活性和容量，如果训练数据集不够大，则过拟合可能是一个严重的问题。当然它在训练集上表现不错，但是训练出的网络并不能运用到它从未见过的新例子！

首先导入必要的包：

```python
import numpy as np
import matplotlib.pyplot as plt
from reg_utils import sigmoid, relu, plot_decision_boundary, initialize_parameters, load_2D_dataset, predict_dec
from reg_utils import compute_cost, predict, forward_propagation, backward_propagation, update_parameters
import sklearn
import sklearn.datasets
import scipy.io
from testCases import *


plt.rcParams['figure.figsize'] = (7.0, 4.0) # set default size of plots
plt.rcParams['image.interpolation'] = 'nearest'
plt.rcParams['image.cmap'] = 'gray'
```

问题陈述：你刚刚被法国足球公司聘为人工智能专家。他们希望你推荐法国守门员踢球的位置，这样法国队的球员就可以用他们的头击球了。

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/Regularization1_zy.png)

他们给你以下来自法国过去10场比赛的二维数据集。

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/Regularization2_zy.png)

每个点对应于足球场上的一个位置，在法国守门员从足球场左侧射门后，足球运动员用头击球。

+ 如果圆点是蓝色的，则表示法国选手设法用头击球

+ 如果圆点是红色的，则表示对方球员用头击球

你的目标：使用一个深度学习模型来找到守门员应该踢球的位置。

---

数据集分析：这个数据集有点嘈杂，但它看起来像一条对角线，将左上半部分（蓝色）和右下半部分（红色）分开，效果很好。

你将首先尝试非正则化模型。然后你将学习如何规范它，并决定你将选择哪种模式来解决法国足球公司的问题。

# 2. Non-regularized model

您将使用以下神经网络（已在下面为您实现）。此模型可用于：

+ 在正则化模式下——通过将lambd输入设置为非零值。我们使用“lambd”而不是“lambda”，因为“lambda”是python中的一个保留关键字。

+ 在dropout模式下——通过将keep_prob设置为小于1的值

首先尝试不带任何正则化的模型。然后，将实现：

+ L2正则化——函数：“compute_cost_with_regularization()”和“backward_propagation_with_regularization()”

+ dropout——函数：“forward_propagation_with_dropout（）”和“backward_propagation_with_dropout（）”

```python
def model(X, Y, learning_rate = 0.3, num_iterations = 30000, print_cost = True, lambd = 0, keep_prob = 1):
    """
    Implements a three-layer neural network: LINEAR->RELU->LINEAR->RELU->LINEAR->SIGMOID.
    
    Arguments:
    X -- input data, of shape (input size, number of examples)
    Y -- true "label" vector (1 for blue dot / 0 for red dot), of shape (output size, number of examples)
    learning_rate -- learning rate of the optimization
    num_iterations -- number of iterations of the optimization loop
    print_cost -- If True, print the cost every 10000 iterations
    lambd -- regularization hyperparameter, scalar
    keep_prob - probability of keeping a neuron active during drop-out, scalar.
    
    Returns:
    parameters -- parameters learned by the model. They can then be used to predict.
    """
        
    grads = {}
    costs = []                            # to keep track of the cost
    m = X.shape[1]                        # number of examples
    layers_dims = [X.shape[0], 20, 3, 1]
    
    # Initialize parameters dictionary.
    parameters = initialize_parameters(layers_dims)

    # Loop (gradient descent)

    for i in range(0, num_iterations):

        # Forward propagation: LINEAR -> RELU -> LINEAR -> RELU -> LINEAR -> SIGMOID.
        if keep_prob == 1:
            a3, cache = forward_propagation(X, parameters)
        elif keep_prob < 1:
            a3, cache = forward_propagation_with_dropout(X, parameters, keep_prob)
        
        # Cost function
        if lambd == 0:
            cost = compute_cost(a3, Y)
        else:
            cost = compute_cost_with_regularization(a3, Y, parameters, lambd)
            
        # Backward propagation.
        assert(lambd==0 or keep_prob==1)    # it is possible to use both L2 regularization and dropout, 
                                            # but this assignment will only explore one at a time
        if lambd == 0 and keep_prob == 1:
            grads = backward_propagation(X, Y, cache)
        elif lambd != 0:
            grads = backward_propagation_with_regularization(X, Y, cache, lambd)
        elif keep_prob < 1:
            grads = backward_propagation_with_dropout(X, Y, cache, keep_prob)
        
        # Update parameters.
        parameters = update_parameters(parameters, grads, learning_rate)
        
        # Print the loss every 10000 iterations
        if print_cost and i % 10000 == 0:
            print("Cost after iteration {}: {}".format(i, cost))
        if print_cost and i % 1000 == 0:
            costs.append(cost)
    
    # plot the cost
    plt.plot(costs)
    plt.ylabel('cost')
    plt.xlabel('iterations (x1,000)')
    plt.title("Learning rate =" + str(learning_rate))
    plt.show()
    
    return parameters
```

```python
parameters = model(train_X, train_Y)
print ("On the training set:")
predictions_train = predict(train_X, train_Y, parameters)
print ("On the test set:")
predictions_test = predict(test_X, test_Y, parameters)
```

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/Non-regularized_model1.png)

训练精度为94.8%，测试精度为91.5%。这是基准模型（你将观察正则化对该模型的影响）。运行以下代码以绘制模型的决策边界。

进一步测试：

```python
plt.title("Model without regularization")
axes = plt.gca()
axes.set_xlim([-0.75,0.40])
axes.set_ylim([-0.75,0.65])
plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y)
```

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/Non-regularized_model2.png)

非正则化模型对训练集的明显过拟合。模型fit了噪音点，现在我们来看两种减少过度拟合的技术。

# 3. L2 Regularization

避免过拟合的标准方法称为l2正则化。它包括适当修改成本函数，从：

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/L2_Regularization1.PNG)

```python
def compute_cost_with_regularization(A3, Y, parameters, lambd):
    """
    Implement the cost function with L2 regularization. See formula (2) above.
    
    Arguments:
    A3 -- post-activation, output of forward propagation, of shape (output size, number of examples)
    Y -- "true" labels vector, of shape (output size, number of examples)
    parameters -- python dictionary containing parameters of the model
    
    Returns:
    cost - value of the regularized loss function (formula (2))
    """
    m = Y.shape[1]
    W1 = parameters["W1"]
    W2 = parameters["W2"]
    W3 = parameters["W3"]
    
    cross_entropy_cost = compute_cost(A3, Y) # This gives you the cross-entropy part of the cost
    
    L2_regularization_cost = (1. / m)*(lambd / 2) * (np.sum(np.square(W1)) + np.sum(np.square(W2)) + np.sum(np.square(W3)))
    
    cost = cross_entropy_cost + L2_regularization_cost
    
    return cost
```

当然，因为你改变了cost，你也必须改变反向传播！所有的梯度都必须根据这个新的cost来计算。

```python
def backward_propagation_with_regularization(X, Y, cache, lambd):
    """
    Implements the backward propagation of our baseline model to which we added an L2 regularization.
    
    Arguments:
    X -- input dataset, of shape (input size, number of examples)
    Y -- "true" labels vector, of shape (output size, number of examples)
    cache -- cache output from forward_propagation()
    lambd -- regularization hyperparameter, scalar
    
    Returns:
    gradients -- A dictionary with the gradients with respect to each parameter, activation and pre-activation variables
    """
    
    m = X.shape[1]
    (Z1, A1, W1, b1, Z2, A2, W2, b2, Z3, A3, W3, b3) = cache
    
    dZ3 = A3 - Y
    
    
    dW3 = 1./m * (np.dot(dZ3, A2.T) + lambd * W3)
    
    db3 = 1./m * np.sum(dZ3, axis=1, keepdims = True)
    
    dA2 = np.dot(W3.T, dZ3)
    dZ2 = np.multiply(dA2, np.int64(A2 > 0))
    
    dW2 = 1./m * (np.dot(dZ2, A1.T) + lambd * W2 )
    
    db2 = 1./m * np.sum(dZ2, axis=1, keepdims = True)
    
    dA1 = np.dot(W2.T, dZ2)
    dZ1 = np.multiply(dA1, np.int64(A1 > 0))
    
    dW1 = 1./m * (np.dot(dZ1, X.T) + lambd * W1 )
    
    db1 = 1./m * np.sum(dZ1, axis=1, keepdims = True)
    
    gradients = {"dZ3": dZ3, "dW3": dW3, "db3": db3,"dA2": dA2,
                 "dZ2": dZ2, "dW2": dW2, "db2": db2, "dA1": dA1, 
                 "dZ1": dZ1, "dW1": dW1, "db1": db1}
    
    return gradients
```

```python
parameters = model(train_X, train_Y, lambd = 0.7)
print ("On the train set:")
predictions_train = predict(train_X, train_Y, parameters)
print ("On the test set:")
predictions_test = predict(test_X, test_Y, parameters)
```

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/L2_Regularization2.png)

从图中可以看出模型收敛地很快，进一步测试：

```python
plt.title("Model with L2-regularization")
axes = plt.gca()
axes.set_xlim([-0.75,0.40])
axes.set_ylim([-0.75,0.65])
plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y)
```

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/L2_Regularization3.png)

你再也不过分拟合训练数据了。

通过观察可以看出：

+ λ的值是一个超参数，可以使用验证集进行调试。

+ L2正则化使决策边界更平滑。如果λ太大，也有可能“过光滑”，导致模型具有很高的偏差。

---

L2正则化到底在做什么？

​		l2正则化依赖于小权重模型比大权重模型简单的假设。因此，通过惩罚cost函数中权重的平方值，可以将所有权重都驱动为较小的值。对于cost函数，更大的权重意味着花费更大！这将导致一个更平滑的模型，在该模型中，随着输入的变化，输出的变化会更慢。

# 4. Dropout

​		最后，dropout是一种广泛使用的正则化技术，它对于深度学习是特殊的。它在每次迭代中随机关闭一些神经元。

​		在每一次迭代中，你关闭（相当于设置为零）一层中每个神经元的概率为l-keep_prop，或者以keep_prob的概率（这里大约是50%）保持它。drop掉的神经元对正向和反向传播的训练都没有贡献。

​		当你关闭一些神经元时，你实际上修改了你的模型。dropout背后的思想是，在每次迭代中，你训练一个不同的模型，它只使用你的神经元的一个子集。通过dropout，你的神经元因此变得对另一个特定神经元的激活函数不那么敏感，因为另一个神经元可能随时被关闭。

（注：视频在images4文件中）

# 5. Forward propagation with dropout

​		实现带dropout的正向传播。你使用的是一个3层的神经网络，并会添加dropout到第一和第二个隐藏层。我们不会将dropout应用到输入层或输出层。

```python
def forward_propagation_with_dropout(X, parameters, keep_prob = 0.5):
    """
    Implements the forward propagation: LINEAR -> RELU + DROPOUT -> LINEAR -> RELU + DROPOUT -> LINEAR -> SIGMOID.
    
    Arguments:
    X -- input dataset, of shape (2, number of examples)
    parameters -- python dictionary containing your parameters "W1", "b1", "W2", "b2", "W3", "b3":
                    W1 -- weight matrix of shape (20, 2)
                    b1 -- bias vector of shape (20, 1)
                    W2 -- weight matrix of shape (3, 20)
                    b2 -- bias vector of shape (3, 1)
                    W3 -- weight matrix of shape (1, 3)
                    b3 -- bias vector of shape (1, 1)
    keep_prob - probability of keeping a neuron active during drop-out, scalar
    
    Returns:
    A3 -- last activation value, output of the forward propagation, of shape (1,1)
    cache -- tuple, information stored for computing the backward propagation
    """
    
    np.random.seed(1)
    
    # retrieve parameters
    W1 = parameters["W1"]
    b1 = parameters["b1"]
    W2 = parameters["W2"]
    b2 = parameters["b2"]
    W3 = parameters["W3"]
    b3 = parameters["b3"]
    
    # LINEAR -> RELU -> LINEAR -> RELU -> LINEAR -> SIGMOID
    Z1 = np.dot(W1, X) + b1
    A1 = relu(Z1)
    ### START CODE HERE ### (approx. 4 lines)         # Steps 1-4 below correspond to the Steps 1-4 described above. 
    D1 = np.random.rand(A1.shape[0], A1.shape[1])                                        # Step 1: initialize matrix D1 = np.random.rand(..., ...)
    D1 = D1 < keep_prob                                         # Step 2: convert entries of D1 to 0 or 1 (using keep_prob as the threshold)
    A1 = np.multiply(A1, D1)                                         # Step 3: shut down some neurons of A1
    A1 /= keep_prob                                        # Step 4: scale the value of neurons that haven't been shut down
    ### END CODE HERE ###
    Z2 = np.dot(W2, A1) + b2
    A2 = relu(Z2)
    ### START CODE HERE ### (approx. 4 lines)
    D2 = np.random.rand(A2.shape[0], A2.shape[1])                                         # Step 1: initialize matrix D2 = np.random.rand(..., ...)
    D2 = D2 < keep_prob                                         # Step 2: convert entries of D2 to 0 or 1 (using keep_prob as the threshold)
    A2 = np.multiply(A2, D2)                                         # Step 3: shut down some neurons of A2
    A2 /= keep_prob                                         # Step 4: scale the value of neurons that haven't been shut down
    ### END CODE HERE ###
    Z3 = np.dot(W3, A2) + b3
    A3 = sigmoid(Z3)
    
    cache = (Z1, D1, A1, W1, b1, Z2, D2, A2, W2, b2, Z3, A3, W3, b3)
    
    return A3, cache
```

# 6. Backward propagation with dropout

```python
def backward_propagation_with_dropout(X, Y, cache, keep_prob):
    """
    Implements the backward propagation of our baseline model to which we added dropout.
    
    Arguments:
    X -- input dataset, of shape (2, number of examples)
    Y -- "true" labels vector, of shape (output size, number of examples)
    cache -- cache output from forward_propagation_with_dropout()
    keep_prob - probability of keeping a neuron active during drop-out, scalar
    
    Returns:
    gradients -- A dictionary with the gradients with respect to each parameter, activation and pre-activation variables
    """
    
    m = X.shape[1]
    (Z1, D1, A1, W1, b1, Z2, D2, A2, W2, b2, Z3, A3, W3, b3) = cache
    
    dZ3 = A3 - Y
    dW3 = 1./m * np.dot(dZ3, A2.T)
    db3 = 1./m * np.sum(dZ3, axis=1, keepdims = True)
    dA2 = np.dot(W3.T, dZ3)
    
    dA2 = np.multiply(dA2, D2)              # Step 1: Apply mask D2 to shut down the same neurons as during the forward propagation
    dA2 /= keep_prob              # Step 2: Scale the value of neurons that haven't been shut down
    
    dZ2 = np.multiply(dA2, np.int64(A2 > 0))
    dW2 = 1./m * np.dot(dZ2, A1.T)
    db2 = 1./m * np.sum(dZ2, axis=1, keepdims = True)
    
    dA1 = np.dot(W2.T, dZ2)
    
    dA1 = np.multiply(dA1, D1)             # Step 1: Apply mask D1 to shut down the same neurons as during the forward propagation
    dA1 /= keep_prob            # Step 2: Scale the value of neurons that haven't been shut down
    
    dZ1 = np.multiply(dA1, np.int64(A1 > 0))
    dW1 = 1./m * np.dot(dZ1, X.T)
    db1 = 1./m * np.sum(dZ1, axis=1, keepdims = True)
    
    gradients = {"dZ3": dZ3, "dW3": dW3, "db3": db3,"dA2": dA2,
                 "dZ2": dZ2, "dW2": dW2, "db2": db2, "dA1": dA1, 
                 "dZ1": dZ1, "dW1": dW1, "db1": db1}
    
    return gradients
```

测试：

```python
parameters = model(train_X, train_Y, keep_prob = 0.86, learning_rate = 0.3)

print ("On the train set:")
predictions_train = predict(train_X, train_Y, parameters)
print ("On the test set:")
predictions_test = predict(test_X, test_Y, parameters)
```

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/Backward_propagation_with_dropout1.png)

进一步测试：

```python
plt.title("Model with dropout")
axes = plt.gca()
axes.set_xlim([-0.75,0.40])
axes.set_ylim([-0.75,0.65])
plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y)
```

![](https://github.com/Qu-rixin/deeplearning.ai-notes/blob/master/02-Improving_Deep_Neural_Networks/week1/images/Backward_propagation_with_dropout2.png)

​		使用dropout的一个常见错误是在训练和测试中都使用它。你应该只在训练中使用退出（随机消除节点）。

​		深度学习框架，如tensorflow、PaddlePaddle、keras或caffe，都有一个辍学层实现。

# 7. Conclusions

​															训练集准确率 测试集准确率

3-layer NN without regularization        95%                91.5%
3-layer NN with L2-regularization         94%                  93%
3-layer NN with dropout                         93%                  95%

​		正规化会损害训练集的性能！这是因为它限制了网络过拟合训练集的能力。但由于它最终能提供更好的测试精度，所以它有助于你的系统。
